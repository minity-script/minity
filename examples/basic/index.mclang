// Declare the namespace. This is where all the following functions will go.
namespace colored_keys

// use /<commend...> to execute minecraft commands. This is useful
// for reusing generated commands from the web, or for commands 
// that don't have syntax sugar provided by McLang
/say Hello World


// All the statements in the root scope of the namespace will be
// executed on (re)load.
/say Tutorial loaded

// Declare an integer variable that will be available in this namespace.
// Variables are stored on the scoreboard under namespaced identifiers
// so you don't need to worry about name clashes with other namespaces.
var $count = 0
function foo  {
  $count++  
  north 0.2 {
    as @p print $count
    unless (stone) foo() 
    else setblock air
  }
}



// If we don't assign a value to the variable, it will be retained from
// between reloads.
var $enabled

as @p print enabled $enabled

// Define a function in the current namespaces. 
// You can call it with function_name() from McLang, or 
// with /function namespace:function:name from the Minecraft command prompt

if ($enabled>0) update_all_locks()

function enable {
  $enabled = 1
  update_all_locks()
}

function disable {
  $enabled = 0
}


tag is_lock
tag is_dead_lock
tag is_blue_lock
tag is_red_lock
tag is_key
tag is_blue_key
tag is_red_key
tag is_book


macro do_update_locks(?is_lock,?is_key,?delta=1) {
  for @s.?is_lock {
    up ?delta if @a[distance = ..2]::Inventory[{tag:{Tags:["{.is_key}"]}}] {
      down ?delta setblock redstone_block
    } // else {
      // down ?delta setblock glass
    //} 
  }
}



macro update_locks(?color,?delta=1) {
  do_update_locks("is_{?color}_lock","{.is_{?color}_key}",?delta)
}

function update_all_locks {
  for @slime.is_lock {
    unless air {
      update_locks(blue)
      update_locks(red)
    } else {
      /say i am dead
      tag is_dead_lock @s
      untag is_lock @s 
      after 3s {
        /say reviving
        for @slime.is_dead_lock {
          untag is_dead_lock @s 
          tag is_lock @s 
          setblock glass
        }        
      }
    }
  }
  after 2t {
    if ( $enabled > 0)  update_all_locks()
  }
}

macro give_lock(?color,?Color,?textColor=white) {
  give @s command_block::{
   display: {
     Name:  json [ {
       color: "{?textColor}",
       text: "Place {?Color} Lock",
       italic: 0b
     }],
     Lore: [
       json [{
         text: "Place this command block to create a {?color} lock.",
         italic: false
       }] 
     ]
   },
   BlockEntityTag:{
     auto: 1b,
     Command: "function colored_keys:summon_{?color}_lock"
   }
  } 
}

function give_blue_lock {
  give_lock(blue,Blue,aqua)
}

function give_red_lock {
  give_lock(red,Red,red)  
}
macro summon_lock(?color,?Color) {
  down 0.5 summon slime::{
    CustomName: json "{?Color} Lock",
    Invulnerable: true,
    Silent: true
  } then {
    @s::NoAI = true
    append @s::Tags "{.is_{?color}_lock}"
    append @s::Tags "{.is_lock}"
    //tag is_lock @s
    setblock glass
  }
}

function summon_blue_lock {
  summon_lock(blue, Blue)
}

function summon_red_lock {
  summon_lock(red, Red)
}

macro give_key(?color, ?Color, ?baseColor) {
  give @s shield::{
    display: {
      Name: json [{
        "text":"{?Color} Key",
        "italic":false
      }],
      Lore: [ 
        json [{
          "text":"This key opens {?color} doors.",
          "italic":false
        }]
      ]
    },
    Tags: ["{.is_key}","{.is_{?color}_key}"],
    //"{.is_key}": 1b,
    //"{.is_{?color}_key}":1b,
    BlockEntityTag: {
      Base: ?baseColor,
      Patterns: [
        { Color: 15, Pattern:"mc" },
        { Color: 15, Pattern:"bt" },
        { Color: ?baseColor, Pattern:"bo" }
      ]
    }
  }
}

function give_blue_key {
  give_key(blue,Blue,3)
}

function give_red_key {
  give_key(red,Red,14)
}

as @a[nbt={Inventory:[{tag:{is_book:1b}}]}] {
  /clear @s minecraft:written_book{is_book:1b}
  give_book()
}

import "./give_book.mclang"