namespace wires
?charge    = 2
?green      = green_wool
?red        = red_wool      
?blue       = blue_wool     
?cyan       = cyan_wool     
?spark      = white_wool    
?and        = orange_wool   
?nand       = purple_wool   
?led_on     = yellow_wool     
?led_off    = gray_wool


?fiber      = white_stained_glass

?tag_green        = "minecraft:{?green}"
?tag_red          = "minecraft:{?red}"
?tag_blue         = "minecraft:{?blue}"
?tag_cyan        = "minecraft:{?cyan}"
?tag_spark        = "minecraft:{?spark}"
?tag_and          = "minecraft:{?and}"
?tag_nand         = "minecraft:{?nand}"
?tag_led_on       = "minecraft:{?led_on}"
?tag_led_off      = "minecraft:{?led_off}"
?tag_fiber        = "minecraft:{?fiber}"


?tags = [ 
  ?tag_spark, ?tag_green, ?tag_blue, ?tag_red, ?tag_cyan,
  ?tag_led_on, ?tag_led_off, ?tag_and, ?tag_nand, ?tag_fiber, 
]

define tags/blocks/wires {
  values:?tags
}

define tags/items/wires {
  values:?tags
}

define tags/blocks/accept_green {
  values:[ ?tag_red, ?tag_green, ?led_on, ?led_off ]
}

define tags/blocks/accept_blue {
  values:[ ?tag_blue, ?tag_green, ?tag_led_on, ?tag_and, ?tag_nand, ?tag_fiber, ?tag_cyan ]
}

define tags/blocks/accept_red {
  values:[ ?tag_blue, ?tag_green, ?tag_red, ?tag_led_off, ?tag_and, ?tag_nand, ?tag_fiber]
}

define tags/blocks/accept_true {
  values:[ ?tag_blue, ?tag_green, ?tag_red, ?tag_and, ?tag_nand, ?tag_fiber ]
}

define tags/blocks/accept_false {
  values:[ ?tag_blue, ?tag_green, ?tag_and, ?tag_cyan, ?tag_nand, ?tag_fiber ]
}

define tags/blocks/accept_on {
  values:[ ?tag_blue, ?tag_red, ?tag_cyan, ?tag_led_off ]
}

define tags/blocks/accept_off {
  values:[ ?tag_blue, ?tag_cyan, ?tag_led_on ]
}


tag orb
tag wire

tag green
tag blue
tag cyan
tag red
tag led_on
tag led_off
tag switch_off
tag switch_on
tag fiber
tag nand
tag and

tag sparked_red
tag sparked_blue
tag sparked_green

tag accept_green
tag accept_red
tag accept_blue
tag accept_true
tag accept_false
tag accept_on
tag accept_off

tag signal_red
tag signal_blue
tag signal_green
tag signal_true
tag signal_false
tag signal_on
tag signal_off
tag changed
tag sparked
tag busy

score charge
score next

/advancement revoke @a only wires:placed_green
/advancement revoke @a only wires:used

function give_orb {
  give @a slime_ball{
    display: {
      Name: json "Wire Master Orb"
    },
    "{.orb}":true
  }
}


macro charge(?signal=signal_green) {
  @s->next = ?charge
  tag @s changed
  tag @s busy
  tag @s ?signal
  if (@s.red) {
    setblock redstone_block
  } else {
    setblock white_wool
  }
}

macro spark(?accept_tag,?sparked_tag) {
  for  @e[distance<1.5].?accept_tag!busy {
    tag @s sparked
    tag @s ?sparked_tag
  }
}

macro set_tags() {
  @s::Tags=[]
  tag @s wire
  if (?red) tag @s red
  if (?blue) tag @s blue
  if (?cyan) tag @s cyan
  if (?green) tag @s green
  if (?led_on) tag @s led_on
  if (?led_off) tag @s led_off
  
  if (?and) tag @s and
  if (?nand) tag @s nand
  if (?fiber) tag @s fiber
  if (#wires:accept_blue) tag @s accept_blue
  if (#wires:accept_red) tag @s accept_red
  if (#wires:accept_green) tag @s accept_green
  if (#wires:accept_true) tag @s accept_true
  if (#wires:accept_false) tag @s accept_false
  if (#wires:accept_on) tag @s accept_on
  if (#wires:accept_off) tag @s accept_off
}

macro set_basic() {
  if @s.red setblock ?red 
  if @s.blue setblock ?blue
  if @s.green setblock ?green
  if @s.cyan setblock ?cyan
  if @s.led_on setblock ?led_on
  if @s.led_off setblock ?led_off
  if @s.and setblock ?and
  if @s.nand setblock ?nand
  if @s.fiber setblock ?fiber
}

macro summon_marker() {
  /kill {@e.wire[distance<0.5]}
  summon marker then {
    @s::PersistenceRequired=true
    set_tags()
    @s->charge=0
  }
}


macro signal(?signal_tag, ?accept_tag, ?sparked_tag, ?trans_block, ?trans_block_2) {
  for @e.?signal_tag {
    if (@s->charge==?charge) {
      spark(?accept_tag,?sparked_tag)
      setblock ?trans_block
    } else if (@s->charge == 1) {
      setblock ?trans_block_2
      untag @s ?signal_tag
      untag @s busy
      set_basic()
    }
    @s->next = @s->charge
    @s->next --
    tag @s changed
      
  }
}

macro signal_red () {
  signal(signal_red,accept_red,sparked_red,pink_wool,red_wool)
}

macro signal_blue () {
  signal(signal_blue,accept_blue,sparked_blue,light_blue_wool,blue_wool)
}

macro signal_green () {
  signal(signal_green,accept_green,sparked_green,lime_wool,green_wool)
}

macro signal_true () {
  signal(signal_true,accept_true,sparked_red,pink_wool,red_wool)
}

macro signal_false () {
  signal(signal_false,accept_false,sparked_blue,light_blue_wool,blue_wool)
}

macro signal_on () {
  signal(signal_on,accept_on,sparked_red,pink_wool,red_wool)
}

macro signal_off () {
  signal(signal_off,accept_off,sparked_blue,light_blue_wool,blue_wool)
}


macro locate_block() {
  var $count=0
  repeat forward 0.09 {
    $count++
  } until #wires:wires and until $count>55 then {
    if #wires:wires resolve() else reject()
  }
}

macro find_block() {
  var $found = false
  anchored eyes when locate_block then {
    $found = true
    resolve()
  }
  unless $found anchored eyes forward 0.03 when locate_block then {
    $found = true
    resolve()
  }
  unless $found anchored eyes forward 0.06 when locate_block then {
    $found = true
    resolve()
  }
  unless $found reject()
}

macro placed_block () {
  when find_block then {
    align xyz if ?spark {
      spark(accept_green,sparked_green)
      setblock air
    } else {
      summon_marker()
    }
  } catch {
    say Something went wrong. Break the block and try again.
  }
}


on minecraft:placed_block{
  player: {
    equipment: {
      offhand: {
        nbt: snbt {"{.orb}":true}
      }
    }
  },
  item: {
    tag: "wires:wires"
  }
} then {
  placed_block()
}

macro update () {  
  for @e.wire if air {
    say dead
    /kill @s
    /kill {@marker[distance<0.5]}
  }
  signal_green()
  signal_red()
  signal_blue()  
  signal_true()  
  signal_false()  
  signal_on()  
  signal_off()  

  for @e.sparked.green!changed charge(signal_green)

  for @e.sparked.blue!changed charge(signal_blue)

  for @e.sparked.red!changed charge(signal_red)

  
  for @e.sparked_blue.nand!changed charge(signal_red)
  for @e.sparked_red.nand!changed charge(signal_blue)
  
  for @e.sparked_blue.and!changed charge(signal_blue)
  for @e.sparked_red.and!changed charge(signal_red)
  
  for @e.sparked_red.fiber!sparked_blue!changed charge(signal_red)
  for @e.sparked_blue.fiber!sparked_red!changed charge(signal_blue)
  
  for @e.sparked_blue.cyan!changed charge(signal_blue)

  for @e.sparked_red.led_off!changed {
    setblock ?led_on
    set_tags()
    charge(signal_on)
  }

  for @e.sparked_blue.led_on!changed {
    setblock ?led_off
    set_tags()
    charge(signal_off)
  }

  for @e.sparked_green.led_on!changed {
    charge(signal_true)
  }

  for @e.sparked_green.led_off!changed {
    charge(signal_false)
  }

  for @e.changed @s->charge=@s->next

  untag @e changed
  untag @e sparked
  untag @e sparked_blue
  untag @e sparked_red
  untag @e sparked_green
}

var $speed = 1 
var $ticks = 0
every 1t {
  var $skip
  $ticks++
  $skip = $ticks
  $skip %= $speed
  unless ($skip) update()
}

function faster() {
  $speed /= 2
  $speed >= 1
}

function slower() {
  $speed *= 2
  $speed <= 32
}

function reset {
  for @e.wire {
    //say setting tags
    @s->charge=0
    set_basic()
    set_tags()
    untag @e.wire changed
    untag @e.wire busy
  }
}

reset()
